访问共享资源的代码区域称为临界区（Critical Sections），临界区需要被以某种互斥机制加以保护。
中断屏蔽、原子操作、自旋锁、信号量、互斥体等是Linux设备驱动中可采用的互斥途径。
## 1.中断屏蔽
中断屏蔽将使得中断与进程之间的并发不再发生，而且，由于Linux内核的进程调度等操作都依赖中断来实现，内核抢占进程之间的并发也得以避免了

使用方法
```c
local_irq_disable() /*屏蔽中断*/
. . .
critical section /*临界区*/
. . .
local_irq_enable() /*开中断*/
```
由于Linux的异步I/O、进程调度等很多重要操作都依赖于中断，中断对于内核的运行非常重要，在屏蔽中断期间所有的中断都无法得到处理，因此长时间屏蔽中断是很危险的，这有可能造成数据丢失乃至系统崩溃等后果。**这就要求在屏蔽了中断之后，当前的内核执行路径应当尽快地执行完临界区的代码。**

local_irq_disable（）和local_irq_enable（）都**只能禁止和使能本CPU内的中断**，因此，并不能解决SMP多CPU引发的竞态。因此，**单独使用中断屏蔽通常不是一种值得推荐的避免竞态的方法**（换句话说，驱动中使用local_irq_disable/enable（）通常意味着一个bug），它适合与下文将要介绍的自旋锁联合使用。

与local_irq_disable（）不同的是，`local_irq_save（flags）`除了进行禁止中断的操作以外，还保存目前CPU的中断位信息，`local_irq_restore（flags）`进行的是与local_irq_save（flags）相反的操作。对于ARM处理器而言，其实就是保存和恢复CPSR。

如果只是想禁止中断的底半部，应使用`local_bh_disable（）`，使能被local_bh_disable（）禁止的底半部应该调用`local_bh_enable（）`。
## 2.原子操作
原子操作可以保证对一个整型数据的修改是排他性的。
原子操作，这些函数又分为两类，分别针对位和整型变量进行原子操作。
### 2.1整型原子操作
### 2.1.1设置原子变量的值
```c
void atomic_set(atomic_t *v, int i); /*设置原子变量的值为i*/
atomic_t v = ATOMIC_INIT(0); /*定义源自变量v并初始化为0*/
```
### 2.1.2获取原子变量的值
```c
atomic_read(atomic_t *v); /*返回原子变量的值*/
```
### 2.1.3原子变量加/减
```c
void atomic_add(int i,atomic_t *v); /*原子变量增加i*/
void atomic_sub(int i,atomic_t *v); /*原子变量减少i*/
```
### 2.1.4原子变量自增/自减
```c
void atomic_inc(atomic_t *v); /*原子变量增加1*/
void atomic_dec(atomic_t *v); /*原子变量减少1*/
```
### 2.1.5操作并测试
```c
int atomic_inc_and_test(atomic_t *v);
int atomic_dec_and_test(atomic_t *v);
int atomic_sub_and_test(int i, atomic_t *v);
```
上述操作对原子变量执行自增、自减和减操作后(没有加)，测试其是否为0，为0返回true，否则返回false。
### 2.1.6操作并返回
```c
int atomic_add_return(int i, atomic_t *v);
int atomic_sub_return(int i, atomic_t *v);
int atomic_inc_return(atomic_t *v);
int atomic_dec_return(atomic_t *v);
```
上述操作对原子变量进行加/减和自增/自减操作，并返回新的值。
## 2.2位原子操作
### 2.2.1设置位
```c
void set_bit(nr, void *addr);/*将地址addr的第nr位置一*/
```
### 2.2.2清除位
```c
void clear_bit(nr,void *addr);/*将地址addr的第nr位清零*/
```
### 2.2.3改变位
```c
void change_bit(nr,void *addr);/*将地址addr的第nr位反转*/
```
### 2.2.4测试位
```c
test_bit(nr, void *addr);/*返回地址addr的第nr位*/
```
### 2.2.5测试并操作位
```c
int test_and_set_bit(nr, void *addr);
int test_and_clear_bit(nr, void *addr);
int test_and_change_bit(nr, void *addr);
```
# 3.自旋锁
