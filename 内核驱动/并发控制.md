访问共享资源的代码区域称为临界区（Critical Sections），临界区需要被以某种互斥机制加以保护。
中断屏蔽、原子操作、自旋锁、信号量、互斥体等是Linux设备驱动中可采用的互斥途径。
## 1.中断屏蔽
中断屏蔽将使得中断与进程之间的并发不再发生，而且，由于Linux内核的进程调度等操作都依赖中断来实现，内核抢占进程之间的并发也得以避免了

使用方法
```c
local_irq_disable() /*屏蔽中断*/
. . .
critical section /*临界区*/
. . .
local_irq_enable() /*开中断*/
```
由于Linux的异步I/O、进程调度等很多重要操作都依赖于中断，中断对于内核的运行非常重要，在屏蔽中断期间所有的中断都无法得到处理，因此长时间屏蔽中断是很危险的，这有可能造成数据丢失乃至系统崩溃等后果。**这就要求在屏蔽了中断之后，当前的内核执行路径应当尽快地执行完临界区的代码。**

local_irq_disable（）和local_irq_enable（）都**只能禁止和使能本CPU内的中断**，因此，并不能解决SMP多CPU引发的竞态。因此，**单独使用中断屏蔽通常不是一种值得推荐的避免竞态的方法**（换句话说，驱动中使用local_irq_disable/enable（）通常意味着一个bug），它适合与下文将要介绍的自旋锁联合使用。

与local_irq_disable（）不同的是，`local_irq_save（flags）`除了进行禁止中断的操作以外，还保存目前CPU的中断位信息，`local_irq_restore（flags）`进行的是与local_irq_save（flags）相反的操作。对于ARM处理器而言，其实就是保存和恢复CPSR。

如果只是想禁止中断的底半部，应使用`local_bh_disable（）`，使能被local_bh_disable（）禁止的底半部应该调用`local_bh_enable（）`。
